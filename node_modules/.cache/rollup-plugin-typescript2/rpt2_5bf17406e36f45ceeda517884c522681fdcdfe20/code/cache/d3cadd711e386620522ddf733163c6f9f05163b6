{"code":"// parser.ts\nimport { TFile, normalizePath, Notice, requestUrl } from \"obsidian\";\nimport { loadTemplate } from \"./bookTemplate\";\nconst PREFIX_CALLMAP = {\n    \"!\": \"warning\",\n    \"@\": \"tip\",\n    \"?\": \"question\",\n    \"/\": \"success\",\n    \"~\": \"abstract\",\n    \"#\": \"info\",\n    \"^\": \"danger\",\n    \"\\\"\": \"quote\",\n    \"xx\": \"example\"\n};\nasync function fetchBookMetadata(title, author) {\n    const query = encodeURIComponent(`intitle:${title} inauthor:${author}`);\n    const url = `https://www.googleapis.com/books/v1/volumes?q=${query}`;\n    try {\n        const response = await requestUrl({ url });\n        const data = response.json;\n        if (!data.items || data.items.length === 0)\n            return null;\n        const volume = data.items[0].volumeInfo;\n        const categories = (volume.categories && volume.categories.join(\", \")) || \"\";\n        return {\n            title: volume.title || title,\n            author: (volume.authors && volume.authors.join(\", \")) || author,\n            publisher: volume.publisher || \"\",\n            publishDate: volume.publishedDate || \"\",\n            totalPage: volume.pageCount?.toString() || \"\",\n            ISBN10: (volume.industryIdentifiers?.find((id) => id.type === \"ISBN_10\")?.identifier) || \"\",\n            ISBN13: (volume.industryIdentifiers?.find((id) => id.type === \"ISBN_13\")?.identifier) || \"\",\n            source: \"Google Books\",\n            url: volume.infoLink || \"\",\n            description: volume.description || \"\",\n            type: categories,\n            date: new Date().toISOString().split(\"T\")[0],\n        };\n    }\n    catch (err) {\n        console.error(\"Failed to fetch metadata:\", err);\n        return null;\n    }\n}\nexport async function parseHighlightFile(plugin, file) {\n    const content = await plugin.app.vault.read(file);\n    const lines = content.split(\"\\n\").map(l => l.trim());\n    const metaLine = lines.shift();\n    if (!metaLine) {\n        new Notice(`File ${file.name} is empty or improperly formatted.`);\n        return;\n    }\n    const metaMatch = metaLine.match(/<<(.+?)>>(.*)/);\n    if (!metaMatch) {\n        new Notice(`Invalid highlight file format in ${file.name}`);\n        return;\n    }\n    const title = metaMatch[1].trim();\n    const author = metaMatch[2].trim();\n    const noteName = plugin.settings.namingConvention === \"TitleAuthor\"\n        ? `${title} - ${author}`\n        : title;\n    const tempPath = normalizePath(`${plugin.settings.booxFolder}/${noteName}.md`);\n    let bookNote = plugin.app.vault.getAbstractFileByPath(tempPath);\n    let metadata = null;\n    if (!bookNote && plugin.settings.enableMetadataFetch) {\n        metadata = await fetchBookMetadata(title, author);\n    }\n    if (!bookNote) {\n        if (!metadata) {\n            metadata = {\n                title,\n                author,\n                publisher: \"\",\n                publishDate: \"\",\n                totalPage: \"\",\n                ISBN10: \"\",\n                ISBN13: \"\",\n                source: \"\",\n                url: \"\",\n                description: \"\",\n                type: \"\",\n                date: new Date().toISOString().split(\"T\")[0],\n            };\n        }\n        const initial = await loadTemplate(plugin.app, metadata);\n        bookNote = await plugin.app.vault.create(tempPath, initial);\n    }\n    else if (plugin.settings.enableMetadataFetch) {\n        metadata = await fetchBookMetadata(title, author);\n        if (metadata && bookNote instanceof TFile) {\n            const fileContent = await plugin.app.vault.read(bookNote);\n            let updated = fileContent;\n            const summaryRegex = /(## Summary\\n+> \\[!abstract\\] Summary\\s+)(.*)/i;\n            if (metadata.description && summaryRegex.test(fileContent)) {\n                updated = updated.replace(summaryRegex, `$1${metadata.description}`);\n            }\n            const yamlRegex = /^---\\n([\\s\\S]*?)\\n---/;\n            const match = updated.match(yamlRegex);\n            if (match) {\n                let yaml = match[1];\n                const replacements = {\n                    publisher: metadata.publisher,\n                    publishdate: metadata.publishDate,\n                    pages: metadata.totalPage,\n                    ISBN10: metadata.ISBN10,\n                    ISBN13: metadata.ISBN13,\n                    source: metadata.source,\n                    url: metadata.url,\n                    type: metadata.type,\n                    highlights: new Date().toISOString()\n                };\n                for (const key in replacements) {\n                    const regex = new RegExp(`^(${key}:).*`, \"m\");\n                    if (yaml.match(regex)) {\n                        yaml = yaml.replace(regex, `$1 ${replacements[key]}`);\n                    }\n                    else {\n                        yaml += `\\n${key}: ${replacements[key]}`;\n                    }\n                }\n                updated = updated.replace(yamlRegex, `---\\n${yaml}\\n---`);\n            }\n            await plugin.app.vault.modify(bookNote, updated);\n        }\n    }\n    if (!(bookNote instanceof TFile))\n        return;\n    const existing = await plugin.app.vault.read(bookNote);\n    let currentBlock = [];\n    const parsedHighlights = [];\n    for (const line of lines) {\n        if (/^[-]{3,}$/.test(line)) {\n            if (currentBlock.length)\n                parsedHighlights.push(currentBlock.join(\"\\n\"));\n            currentBlock = [];\n        }\n        else {\n            currentBlock.push(line);\n        }\n    }\n    if (currentBlock.length)\n        parsedHighlights.push(currentBlock.join(\"\\n\"));\n    let added = 0;\n    for (const block of parsedHighlights) {\n        const parsed = parseBooxBlock(block);\n        const formatted = formatCitation(plugin.settings.citationStyle, title, author, parsed.page, parsed.highlight, parsed.timestamp, parsed.annotation);\n        if (!existing.includes(parsed.highlight)) {\n            await plugin.app.vault.append(bookNote, `\\n${formatted}\\n`);\n            added++;\n        }\n    }\n    if (added > 0)\n        new Notice(`Added ${added} new highlight(s) to ${noteName}`);\n    // Move processed file to final folder\n    const finalPath = normalizePath(`${plugin.settings.moveCompletedTo}/${noteName}.md`);\n    const existingFinal = plugin.app.vault.getAbstractFileByPath(finalPath);\n    if (!existingFinal && bookNote instanceof TFile) {\n        await plugin.app.fileManager.renameFile(bookNote, finalPath);\n    }\n    await plugin.app.vault.delete(file);\n}\nfunction parseBooxBlock(block) {\n    const lines = block.split(\"\\n\").map(l => l.trim()).filter(Boolean);\n    let section = \"\", timestamp = \"\", page = \"\", highlight = \"\", annotation = \"\";\n    if (lines[0] && lines[0].includes(\"| Page No.:\")) {\n        const metaLine = lines.shift();\n        if (metaLine) {\n            [timestamp, page] = metaLine.split(\"| Page No.:\").map(s => s.trim());\n        }\n    }\n    else {\n        section = lines.shift() || \"\";\n        if (lines[0] && lines[0].includes(\"| Page No.:\")) {\n            const metaLine = lines.shift();\n            if (metaLine) {\n                [timestamp, page] = metaLine.split(\"| Page No.:\").map(s => s.trim());\n            }\n        }\n    }\n    for (const line of lines) {\n        if (line.includes(\"【Annotation】\")) {\n            annotation = line.replace(\"【Annotation】\", \"\").trim();\n        }\n        else {\n            highlight += (highlight ? \" \" : \"\") + line;\n        }\n    }\n    return { section, timestamp, page, highlight: highlight.trim(), annotation };\n}\nfunction formatCitation(style, title, author, page, highlight, timestamp, annotation) {\n    let citationLine = \"\";\n    switch (style) {\n        case \"APA\":\n            citationLine = `${author} (${new Date(timestamp).getFullYear()}). *${title}*. \\\"${highlight}\\\" p. ${page}.`;\n            break;\n        case \"Chicago\":\n            citationLine = `${author}, *${title}* (${page}): \\\"${highlight}\\\".`;\n            break;\n        case \"MLA\":\n        default:\n            citationLine = `${author}. \\\"${highlight}\\\" *${title}*, p. ${page}.`;\n            break;\n    }\n    let output = `- ${citationLine}\\n  *Added on ${timestamp}*`;\n    if (annotation) {\n        const prefixMatch = annotation.match(/^(\\^|\\/|@|\\?|~|#|!|\\\"|xx)/);\n        let prefix = \"\";\n        let content = annotation;\n        if (prefixMatch) {\n            prefix = prefixMatch[1];\n            content = annotation.slice(prefix.length).trim();\n        }\n        const calloutType = PREFIX_CALLMAP[prefix] || \"note\";\n        output += `\\n  > [!${calloutType}] ${content}`;\n    }\n    return output;\n}\n","references":["/Users/muhammad_saadiq/Documents/@L-P/Obsidian/ArRahman/BooxSync-Starter/node_modules/obsidian/obsidian.d.ts","/Users/muhammad_saadiq/Documents/@L-P/Obsidian/ArRahman/BooxSync-Starter/src/main.ts","/Users/muhammad_saadiq/Documents/@L-P/Obsidian/ArRahman/BooxSync-Starter/src/settings.ts","/Users/muhammad_saadiq/Documents/@L-P/Obsidian/ArRahman/BooxSync-Starter/src/bookTemplate.ts"]}
