{"code":"// parser.ts\nimport { TFile, normalizePath, Notice, requestUrl } from \"obsidian\";\nimport { loadTemplate } from \"./bookTemplate\";\nconst PREFIX_CALLMAP = {\n    \"!\": \"warning\",\n    \"@\": \"tip\",\n    \"?\": \"question\",\n    \"/\": \"success\",\n    \"~\": \"abstract\",\n    \"#\": \"info\",\n    \"^\": \"danger\",\n    '\"': \"quote\",\n    \"xx\": \"example\"\n};\nasync function fetchBookMetadata(title, author) {\n    const query = encodeURIComponent(`intitle:${title} inauthor:${author}`);\n    const url = `https://www.googleapis.com/books/v1/volumes?q=${query}`;\n    try {\n        const response = await requestUrl({ url });\n        const data = response.json;\n        if (!data.items || data.items.length === 0)\n            return null;\n        const volume = data.items[0].volumeInfo;\n        const categories = (volume.categories && volume.categories.join(\", \")) || \"\";\n        return {\n            title: volume.title || title,\n            author: (volume.authors && volume.authors.join(\", \")) || author,\n            publisher: volume.publisher || \"\",\n            publishDate: volume.publishedDate || \"\",\n            totalPage: volume.pageCount?.toString() || \"\",\n            ISBN10: (volume.industryIdentifiers?.find((id) => id.type === \"ISBN_10\")?.identifier) || \"\",\n            ISBN13: (volume.industryIdentifiers?.find((id) => id.type === \"ISBN_13\")?.identifier) || \"\",\n            source: \"Google Books\",\n            url: volume.infoLink || \"\",\n            description: volume.description || \"\",\n            type: categories,\n            date: new Date().toISOString().split(\"T\")[0],\n            highlights: \"\"\n        };\n    }\n    catch (err) {\n        console.error(\"Failed to fetch metadata:\", err);\n        return null;\n    }\n}\nexport async function parseHighlightFile(plugin, file) {\n    const content = await plugin.app.vault.read(file);\n    const lines = content.split(\"\\n\").map(l => l.trim());\n    const metaLine = lines.shift();\n    if (!metaLine) {\n        new Notice(`File ${file.name} is empty or improperly formatted.`);\n        return;\n    }\n    const metaMatch = metaLine.match(/<<(.*?)>>(.*)/);\n    if (!metaMatch) {\n        new Notice(`Invalid highlight file format in ${file.name}`);\n        return;\n    }\n    const title = metaMatch[1].trim();\n    const author = metaMatch[2].trim();\n    const noteName = plugin.settings.namingConvention === \"TitleAuthor\" ? `${title} - ${author}` : title;\n    const notePath = normalizePath(`${plugin.settings.outputFolder}/${noteName}.md`);\n    let bookNote = plugin.app.vault.getAbstractFileByPath(notePath);\n    let metadata = null;\n    if (!bookNote && plugin.settings.enableMetadataFetch) {\n        metadata = await fetchBookMetadata(title, author);\n    }\n    if (!bookNote) {\n        if (!metadata) {\n            metadata = {\n                title,\n                author,\n                publisher: \"\",\n                publishDate: \"\",\n                totalPage: \"\",\n                ISBN10: \"\",\n                ISBN13: \"\",\n                source: \"\",\n                url: \"\",\n                description: \"\",\n                type: \"\",\n                date: new Date().toISOString().split(\"T\")[0],\n                highlights: \"\"\n            };\n        }\n        const initial = await loadTemplate(plugin.app, metadata);\n        bookNote = await plugin.app.vault.create(notePath, initial);\n    }\n    if (!(bookNote instanceof TFile))\n        return;\n    let existing = await plugin.app.vault.read(bookNote);\n    if (metadata?.description) {\n        const summaryRegex = /(## Summary\\n+> \\[!abstract\\] Summary\\s+)(.*)/i;\n        existing = existing.replace(summaryRegex, `$1${metadata.description}`);\n        await plugin.app.vault.modify(bookNote, existing);\n    }\n    let currentBlock = [];\n    const parsedBlocks = [];\n    for (const line of lines) {\n        if (/^[-]{3,}$/.test(line)) {\n            if (currentBlock.length)\n                parsedBlocks.push(currentBlock.join(\"\\n\"));\n            currentBlock = [];\n        }\n        else {\n            currentBlock.push(line);\n        }\n    }\n    if (currentBlock.length)\n        parsedBlocks.push(currentBlock.join(\"\\n\"));\n    let added = 0;\n    let latestTimestamp = \"\";\n    for (const block of parsedBlocks) {\n        const parsed = parseBooxBlock(block);\n        if (!parsed.highlight ||\n            (existing.includes(parsed.highlight) && existing.includes(parsed.timestamp)))\n            continue;\n        const quote = formatCitation(plugin.settings.citationStyle, title, author, parsed.page, parsed.highlight, parsed.timestamp);\n        let output = `> [!quote]\\n> ${quote}\\n> *Added on ${new Date(parsed.timestamp).toLocaleString()}*`;\n        if (parsed.annotation) {\n            const prefixMatch = parsed.annotation.match(/^(\\^|\\/|@|\\?|~|#|!|\"|xx)/);\n            let prefix = \"\";\n            let content = parsed.annotation;\n            if (prefixMatch) {\n                prefix = prefixMatch[1];\n                content = parsed.annotation.slice(prefix.length).trim();\n            }\n            const calloutType = PREFIX_CALLMAP[prefix] || \"note\";\n            const [label, annotationBody] = content.split(\"|\").map(p => p.trim());\n            output += `\\n\\n> [!${calloutType}] ${label}\\n> ${annotationBody}`;\n        }\n        await plugin.app.vault.append(bookNote, `\\n\\n${output}\\n`);\n        added++;\n        if (!latestTimestamp || new Date(parsed.timestamp) > new Date(latestTimestamp)) {\n            latestTimestamp = parsed.timestamp;\n        }\n    }\n    if (added > 0 && latestTimestamp) {\n        const fileContent = await plugin.app.vault.read(bookNote);\n        const updated = fileContent.replace(/(highlights:).*/i, `$1 ${latestTimestamp}`);\n        await plugin.app.vault.modify(bookNote, updated);\n        new Notice(`Added ${added} new highlight(s) to ${noteName}`);\n    }\n    await plugin.app.vault.delete(file);\n    const finalPath = normalizePath(`${plugin.settings.moveCompletedTo}/${noteName}.md`);\n    await new Promise(resolve => setTimeout(resolve, 500));\n    const fresh = plugin.app.vault.getAbstractFileByPath(notePath);\n    if (fresh instanceof TFile) {\n        await plugin.app.fileManager.renameFile(fresh, finalPath);\n    }\n}\nfunction parseBooxBlock(block) {\n    const lines = block.split(\"\\n\").map(l => l.trim()).filter(Boolean);\n    let section = \"\", timestamp = \"\", page = \"\", highlight = \"\", annotation = \"\";\n    if (lines[0] && lines[0].includes(\"| Page No.:\")) {\n        const metaLine = lines.shift();\n        if (metaLine)\n            [timestamp, page] = metaLine.split(\"| Page No.:\").map(s => s.trim());\n    }\n    else {\n        section = lines.shift() || \"\";\n        if (lines[0] && lines[0].includes(\"| Page No.:\")) {\n            const metaLine = lines.shift();\n            if (metaLine)\n                [timestamp, page] = metaLine.split(\"| Page No.:\").map(s => s.trim());\n        }\n    }\n    for (const line of lines) {\n        if (line.includes(\"【Annotation】\")) {\n            annotation = line.replace(\"【Annotation】\", \"\").trim();\n        }\n        else {\n            highlight += (highlight ? \" \" : \"\") + line;\n        }\n    }\n    return { section, timestamp, page, highlight: highlight.trim(), annotation };\n}\nfunction formatCitation(style, title, author, page, highlight, timestamp) {\n    switch (style) {\n        case \"APA\":\n            return `${author} (${new Date(timestamp).getFullYear()}). *${title}*. \\\"${highlight}\\\" p. ${page}.`;\n        case \"Chicago\":\n            return `${author}, *${title}* (${page}): \\\"${highlight}\\\".`;\n        case \"MLA\":\n        default:\n            return `${author}. \\\"${highlight}\\\" *${title}*, p. ${page}.`;\n    }\n}\n","references":["/Users/muhammad_saadiq/Documents/@L-P/Obsidian/Plugins/BooxSync-Starter/node_modules/obsidian/obsidian.d.ts","/Users/muhammad_saadiq/Documents/@L-P/Obsidian/Plugins/BooxSync-Starter/src/main.ts","/Users/muhammad_saadiq/Documents/@L-P/Obsidian/Plugins/BooxSync-Starter/src/settings.ts","/Users/muhammad_saadiq/Documents/@L-P/Obsidian/Plugins/BooxSync-Starter/src/bookTemplate.ts"]}
